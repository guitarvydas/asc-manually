# types
  rid = {
    path
    ns
    name
  }

  thing = compound { val component }

  val = any

  component = :foreign
  parent-component = component

  any = :foreign

  string = :foreign
  path = :foreign
  ns = :foreign
  name = :foreign

  yesno = 'yes' | 'no'
  
# end types

# signatures
# end signatures

# foreign methods
# end foreign methods

# implementation

def-top-level-component% <name
      design rule top level component must not exist <name
    @create component at top level <name
    nothing

def-contained-component% <rid
    component = deep define path creating intermediaries <rid
    nothing

// (("hwapp" "c" "inner") "i" "a")
def-input% <rid
    component = get rid.path
      design rule must be a component <component
      ns = rid.ns
def-output% <rid

get% <rid >thing
    component = deep get component <rid
    design rule `value must exist' <component <rid.ns <rid.name
    val = @raw get value <component <rid.ns <rid.name
    val
    
set% <rid <val
    component = deep get component <rid
    design rule `value must not exist' <component <rid.ns <rid.name
    @raw set value <component <rid.ns <rid.name <val
    nothing
    
deep define path creating intermediaries <rid >component
deep get component <rid >component

# end implementation
# design rules
must refer to component namespace <str
    succeeds str === "c"
must refer to input namespace <str
    succeeds str === "i"
must refer to output namespace <str
    succeeds str === "o"
component must exist <component
    succeeds lookup-component <component
value must exist <component <namespace <name
    fails lookup-value <component <namespace <name
value must not exist <component <namespace <name
    fails lookup-value <component <namespace <name

must be a component <component

toplevel component must not exist <name

# end design rules   


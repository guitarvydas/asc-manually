# types
  rid = {
    path
    ns
    name
  }

  thing = compound { val component }

  val = any

  component = :foreign
  parent-component = component

  any = :foreign

  string = :foreign
  path = :foreign
  ns = :foreign
  name = :foreign

  yesno = 'yes' | 'no'
  
# end types

# signatures

  def% <rid
  get% <rid >thing
  set% <rid <val
  deep define path creating intermediaries <rid >component
  deep get component <rid >component

# end signatures

# foreign methods
   raw get value <component <ns <name
   raw set <component <ns <name <val
   lookup or create component at top level <name >component
   lookup or create contained component <parent-component <ns <name <child >component
   lookup component at top level <name >component
   lookup contained component <parent-component <ns <name >component
   is leaf <rid >yesno
# end foreign methods

# implementation
def% <rid
    component = deep define path creating intermediaries <rid
    nothing

get% <rid >thing
    component = deep get component <rid
    design rule `value must exist' <component <rid.ns <rid.name
    val = @raw get value <component <rid.ns <rid.name
    val
    
set% <rid <val
    component = deep get component <rid
    design rule `value must not exist' <component <rid.ns <rid.name
    @raw set <component <rid.ns <rid.name <val
    nothing
    
// ((("hwapp" "c" "1") "c" "2") "i" "3")
//consider only path: (("hwapp" "c" "1") "c" "2")
deep define path creating intermediaries <rid >component
        design rule `must refer to component namespace' <rid.ns
    [ @is leaf <rid.path
      yes -> 
        cname = rid.path
        component = @lookup or create component at top level <cname
        component
      no  ->
        deep define path creating intermediaries <rid.path >parent-component
        child = deep get component <rid
	component = @lookup or create contained component <parent-component <rid.ns <rid.name <child
	component	      
    ]

deep get component <rid >component
    [ @is leaf <rid.path
      yes -> 
        component = @lookup component at top level <rid.path
	design rule `component must exist' <component
        component
      no  ->
          design rule `must refer to component namespace' <rid.ns
	component = @lookup contained component <parent-component <rid.ns <rid.name
	component	      
    ]

# end implementation
# design rules
must refer to component namespace <str
    succeeds str === "c"
component must exist <component
    succeeds lookup-component <component
value must exist <component <namespace <name
    fails lookup-value <component <namespace <name
value must not exist <component <namespace <name
    fails lookup-value <component <namespace <name
# end design rules   


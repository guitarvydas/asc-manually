# types
  rid = {
    path
    ns
    name
  }

  thing = compound { val component }

  val = any

  component = :foreign
  parent-component = component
  child = component

  any = :foreign

  string = :foreign
  path = :foreign
  ns = :foreign
  name = :foreign

  yesno = 'yes' | 'no'
  
# end types

# signatures

// RID means Relative ID
def-component% <rid
def-input% <rid
def-output% <rid
get% <rid >val
set% <rid <val

# layer effective address
// ea means Effective Address - the resolved path part of a RID
ea% <path >component
def-ea% <path >component
# end layer effective address

# end signatures

# foreign functions
// foreign functions are defined elsewhere (in the base language)
// synchronous and always return a value
is leaf <rid >yesno
lookup component at top level <path <ns <name >component
lookup contained component <path <ns <name >component
lookup or create component at top level <path <ns <name >component
lookup or create contained component <path <ns <name >component
create input pin raw <path <ns <name
create output pin raw <path <ns <name
raw get <parent <rid.ns <rid.name
raw set <parent <rid.ns <rid.name <v
# end foreign functions

# implementation

def-top-level-component% <name
  component = @lookup or create component at top level <name
  component

def-contained-component% <rid
  outer = def-ea% <rid.path
    design rule `must use component namespace' <rid
  component = @lookup or create contained component <path.path <path.ns <path.name
  component

def-input% <rid
  outer = ea% <rid.path
    design rule `must use input namespace' <rid
    design rule `input pin must not be defined more than once` <outer <rid.ns <rid.name
  @create-input-pin-raw <outer <rid.ns <rid.name
  nothing   

def-output% <rid
  outer = ea% <rid.path
    design rule `must use output namespace' <path
    design rule `output pin must not be defined more than once` <outer <rid.ns <rid.name
  @create-output-pin-raw <out <rid.ns <rid.name
  nothing   

get% <rid >val
  parent = ea% <rid.path
    design rule `must be a valid namespace' <rid
    design rule `value must exist' <parent <rid.ns <rid.name
  v = @raw-get <parent <rid.ns <rid.name
  v
   
set% <rid <val
  parent = ea% <rid.path
    design rule `must be a valid namespace' <rid
    design rule `value must not exist' <parent <rid.ns <rid.name
  @raw-set <parent <rid.ns <rid.name <v
  nothing   

add-connection% <rid <rid1 <rid1
  parent = ea% <rid.path
    design rule `must use connection namespace' <rid
    design rule `must use i/o namespace' <rid1
    design rule `must use i/o namespace' <rid2
  @raw-add-connection <rid.name <parent <rid1 <rid2

# layer `effective address'
ea% <path >component
    design rule `must use component namespace' <path.ns
  [ @is leaf <path
    yes -> component = @lookup component at top level <path
    no  ->
      outer = ea% <path.path
        design rule `must be a component' <outer
        design rule `value must exist' <outer <path.ns <path.name
      component = @lookup contained component <outer <path.ns <path.name
  ]
  component


def-ea% <path >component
  [ @is leaf <path.path
    yes -> component = @lookup or create component at top level <path.path <path.ns <path.name
    no  ->
      outer = ea% <path.path
      component = @lookup or create contained component <outer <path.ns <path.name
  ]
  component
# end layer `effective address'


# end implementation

# design rules
`must use component namespace' <rid
`must use input namespace' <rid
`must use output namespace' <rid
`input pin must not be defined more than once` <component <ns <name
`output pin must not be defined more than once` <component <ns <name
`must be a valid namespace' <rid
`value must exist' <path <ns <name
`value must not exist' <path <ns <name
`must be a component' <any
`must use connection namespace' <rid
`must use i/o namespace' <rid
# end design rules

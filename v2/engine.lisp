(defun def-top-level-component% (s)
  (let ((component (lookup-or-create-component-at-top-level s)))
    component))

(defun def-contained-component% (rid)
  (let ((outer (def-ea% (path rid)))
	component)
    (design-rule-must-use-component-namespace rid)
    (setf component (lookup-or-create-contained-component outer (ns rid) (name rid)))
    component))

(defun def-input% (rid)
  (let ((outer (ea% (path rid))))
    (design-rule-must-use-input-namespace rid)
    (design-rule-input-pin-must-not-be-defined-more-than-once outer (ns rid) (name rid))
    (let (component)
      (declare (ignore component))
      (create-input-pin-raw outer (ns rid) (name rid)))))

(defun def-output% (rid)
  (let ((outer (ea% (path rid))))
    (design-rule-must-use-output-namespace rid)
    (design-rule-output-pin-must-not-be-defined-more-than-once outer (ns rid) (name rid))
    (let (component)
      (declare (ignore component))
      (create-output-pin-raw outer (ns rid) (name rid)))))

(defun get% (rid)
  (let ((parent (ea% (path rid))))
    (design-rule-must-be-a-valid-namespace rid)
    (design-rule-value-must-exist parent (ns rid) (name rid))
    (let ((v (raw-get parent (ns rid) (name rid))))
      v)))
      
(defun set% (rid val)
  (let ((parent (ea% (path rid))))
    (design-rule-must-be-a-valid-namespace rid)
    (design-rule-value-must-not-exist parent (ns rid) (name rid))
    (raw-set parent (ns rid) (name rid) val)))

(defun add-connection% (rid sender-rid receiver-rid)
  (let ((parent (ea% (path rid)))):a
    (design-rule-must-use-connection-namespace rid)
    (design-rule-must-use-io-namespace sender-rid)
    (design-rule-must-use-io-namespace receiver-rid)
    (raw-add-connection (name rid) parent sender-rid receiver-rid)))

;; layer effective address
(defun ea% (path)
  (let (component)
    (if (eq 'yes (is-leaf path))
        (let ((component-string-name path))
          (setf component (lookup-component-at-top-level component-string-name)))
	(let ((outer (ea% (path path))))
          (design-rule-must-use-component-namespace path)
	  (design-rule-must-be-a-component outer)
	  (design-rule-value-must-exist outer (ns path) (name path))
	  (setf component (lookup-contained-component outer (ns path) (name path)))))
    component))

(defun def-ea% (path)
  (let (component)
    (if (eq 'yes (is-leaf path))
        (let ((component-string-name path))
          (setf component (lookup-or-create-component-at-top-level component-string-name)))
	(let ((outer (ea% (path path))))
	  (setf component (lookup-or-create-contained-component outer (ns path) (name path)))))
    component))

;; end layer effective address
